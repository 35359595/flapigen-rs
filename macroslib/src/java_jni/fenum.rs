use quote::quote;
use std::{io::Write, path::Path};

use super::{
    java_class_full_name, java_class_name_to_jni, java_code::doc_comments_to_java_comments,
    map_write_err, JavaContext,
};
use crate::{
    error::{DiagnosticError, Result},
    file_cache::FileWriteCache,
    source_registry::SourceId,
    typemap::ast::DisplayToTokens,
    types::ForeignEnumInfo,
    WRITE_TO_MEM_FAILED_MSG,
};

pub(in crate::java_jni) fn generate_enum(
    ctx: &mut JavaContext,
    enum_info: &ForeignEnumInfo,
) -> Result<()> {
    if (enum_info.items.len() as u64) >= (i32::max_value() as u64) {
        return Err(DiagnosticError::new(
            enum_info.src_id,
            enum_info.span(),
            "Too many items in enum",
        ));
    }

    generate_java_code_for_enum(&ctx.cfg.output_dir, &ctx.cfg.package_name, enum_info)
        .map_err(|err| DiagnosticError::new(enum_info.src_id, enum_info.span(), &err))?;
    generate_rust_code_for_enum(ctx, enum_info)?;
    Ok(())
}

fn generate_java_code_for_enum(
    output_dir: &Path,
    package_name: &str,
    enum_info: &ForeignEnumInfo,
) -> std::result::Result<(), String> {
    let path = output_dir.join(format!("{}.java", enum_info.name));
    let mut file = FileWriteCache::new(&path);
    let enum_doc_comments = doc_comments_to_java_comments(&enum_info.doc_comments, true);
    write!(
        file,
        r#"// Automaticaly generated by rust_swig
package {package_name};

{doc_comments}
public enum {enum_name} {{
"#,
        package_name = package_name,
        enum_name = enum_info.name,
        doc_comments = enum_doc_comments,
    )
    .expect(WRITE_TO_MEM_FAILED_MSG);

    for (i, item) in enum_info.items.iter().enumerate() {
        writeln!(
            file,
            "{doc_comments}{item_name}({index}){separator}",
            item_name = item.name,
            index = i,
            doc_comments = doc_comments_to_java_comments(&item.doc_comments, false),
            separator = if i == enum_info.items.len() - 1 {
                ';'
            } else {
                ','
            },
        )
        .expect(WRITE_TO_MEM_FAILED_MSG);
    }

    write!(
        file,
        r#"
    private int value;
    {enum_name}(int value) {{
        this.value = value;
    }}
    public final int getValue() {{ return value; }}
}}
"#,
        enum_name = enum_info.name
    )
    .expect(WRITE_TO_MEM_FAILED_MSG);

    file.update_file_if_necessary().map_err(&map_write_err)?;
    Ok(())
}

fn generate_rust_code_for_enum(ctx: &mut JavaContext, enum_info: &ForeignEnumInfo) -> Result<()> {
    let mut arms_to_jint = Vec::with_capacity(enum_info.items.len());
    let mut arms_from_jint = Vec::with_capacity(enum_info.items.len());
    assert!((enum_info.items.len() as u64) <= u64::from(i32::max_value() as u32));
    for (i, item) in enum_info.items.iter().enumerate() {
        let item_name = &item.rust_name;
        let idx = i as i32;
        arms_to_jint.push(quote! { #item_name => #idx });
        arms_from_jint.push(quote! { #idx => #item_name });
    }

    let rust_enum_name = &enum_info.name;

    ctx.rust_code.push(quote! {
        impl SwigForeignCLikeEnum for #rust_enum_name {
            fn as_jint(&self) -> jint {
                match *self {
                    #(#arms_to_jint),*
                }
            }
            fn from_jint(x: jint) -> Self {
                match x {
                    #(#arms_from_jint),*
                    ,
                    _ => panic!(concat!("{} not expected for ", stringify!(#rust_enum_name)), x),
                }
            }
        }
    });

    use std::fmt::Write;

    let rust_enum_name = enum_info.rust_enum_name();
    let mut code = format!(
        r#"
impl SwigFrom<jint> for {rust_enum_name} {{
    fn swig_from(x: jint, _: *mut JNIEnv) -> {rust_enum_name} {{
        {rust_enum_name}::from_jint(x)
    }}
}}
"#,
        rust_enum_name = rust_enum_name,
    );

    let java_enum_full_name =
        java_class_full_name(&ctx.cfg.package_name, &enum_info.name.to_string());
    let enum_class_name = java_class_name_to_jni(&java_enum_full_name);

    write!(
        &mut code,
        r#"
mod swig_foreign_types_map {{
    #![swig_foreigner_type = "{enum_name}"]
    #![swig_rust_type_not_unique = "jobject"]
}}
#[swig_to_foreigner_hint = "{enum_name}"]
impl SwigFrom<{rust_enum_name}> for jobject {{
   fn swig_from(x: {rust_enum_name}, env: *mut JNIEnv) -> jobject {{
       let cls: jclass = unsafe {{ (**env).FindClass.unwrap()(env, swig_c_str!("{class_name}")) }};
       assert!(!cls.is_null(), "FindClass {class_name} failed");
       let static_field_id = match x {{
"#,
        enum_name = enum_info.name,
        rust_enum_name = rust_enum_name,
        class_name = enum_class_name,
    )
    .unwrap();

    for item in &enum_info.items {
        write!(
            &mut code,
            r#"
           {rust_item} => swig_c_str!("{java_item}"),
"#,
            rust_item = DisplayToTokens(&item.rust_name),
            java_item = item.name,
        )
        .unwrap();
    }
    write!(
        &mut code,
        r#"
      }};
      let item_id: jfieldID = unsafe {{
          (**env).GetStaticFieldID.unwrap()(env, cls , static_field_id,
                                             swig_c_str!("L{class_name};"))
      }};
      assert!(!item_id.is_null(), "Can not find item in {class_name}");
      let ret: jobject = unsafe {{
        (**env).GetStaticObjectField.unwrap()(env, cls, item_id)
      }};
      assert!(!ret.is_null(), "Can get value of item in {class_name}");
      ret
   }}
}}
"#,
        class_name = enum_class_name,
    )
    .unwrap();
    ctx.conv_map.register_exported_enum(enum_info);
    ctx.conv_map
        .merge(SourceId::none(), &code, ctx.pointer_target_width)?;
    Ok(())
}
